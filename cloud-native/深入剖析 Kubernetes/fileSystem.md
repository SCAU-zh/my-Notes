# 容器的文件系统

> Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。



对 docker 项目来说 ，最核心的原理应该是为待创建的用户进程：

- 启用 Linux Namespace 配置
- 设置指定的 Cgroups 参数
- 切换进程的根目录 （change root）：优先使用 pivot_root ，如果系统不支持再使用 chroot



rootfs: 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核，实际上，**同一台机器上的容器都是共享宿主机的操作系统内核**。

## docker 如何处理镜像的增量修改？

> Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。



这个想法用到了 unionFS（union file system 联合文件系统）的能力：

将多个不同位置的目录联合挂载到同一个目录。



例子：

``` shell
# 在目录 A, B 中有各自的2个文件
$ tree
.
├── A
│  ├── a
│  └── x
└── B
  ├── b
  └── x
  
# 使用联合挂载，将这两个目录挂载到公共目录 C
$ mkdir C
$ mount -t aufs -o dirs=./A:./B none ./C

# 目录 C

$ tree ./C
./C
├── a
├── b
└── x
# 可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。
```



在 Ubuntu 16.04 和 Docker CE 18.05 环境中，默认使用 auFs 联合文件系统的实现。

镜像的层都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载在 /var/lib/docker/aufs/mnt 里面。

如下图：

![](https://notes-1303113205.cos.ap-guangzhou.myqcloud.com/my-notes-image/111.webp)



### 第一部分：只读层

是容器 rootfs最下面的层。

挂载方式是只读的(readonly + whiteout)

可是，你有没有想到这样一个问题：如果我现在要做的，是删除只读层里的一个文件呢？为了实现这样的删除操作，AuFS 会在可读写层

创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在

可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个

功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。

### 第二部分：可读写层

是容器 rootfs 最上面的一层，挂载方式是read write，

在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。

该层的作用，就是存放修改 rootfs 后的增量，包括增删改操作。而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。

### 第三部分：init 层

它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，init 层存放容器在运行时修改过的

配置文件，这些配置仅对当前容器有效，因此 docker commit 时不会随同读写层一起提交。

