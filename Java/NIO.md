# JAVA NIO 浅析

## 传统的同步阻塞I/O （BIO: Blocking I/O）
### 特点
- 一个连接由一个线程来处理
- 每个线程内处理请求是阻塞的，如果系统是单线程模型的话，当有连接在处理时，系统是阻塞的
- I/O 模型阻塞，但 CPU 是空闲的话，可以利用多线程让 CPU 处理更多的事情。

### 应用场景
BIO 模型一般会配合多线程来使用，而多线程一般通过线程池来实现，减少线程创建和回收的成本，在活动连接数比较少的情况下（1000 左右）适用。

### 问题
**严重依赖于进程**，线程是宝贵的资源。
> 1. 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。 
> 2. 线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。 
> 3. 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。 
> 4. 容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。